using System.Collections.Generic;

using Prem.Util;
using Prem.Transformer.TreeLang;

using semantics Prem.Transformer.TreeLang.Semantics;
using learners Prem.Transformer.TreeLang.WitnessFunctions;

language TreeLang;

@complete feature double Score = Prem.Transformer.TreeLang.RankingScore;

@input TInput source;

@start SyntaxNode program := Ins(target, k, newTree) | Del(target) | Upd(target, newTree);

SyntaxNode newTree := New(tree);

PartialNode tree := Copy(target)
                  | RefToken(source, i, label)
                  | ConstToken(code, label)
                  | Tree(label, children);

IEnumerable<PartialNode> children := Child(tree) | Children(tree, children);

SyntaxNode target := Target(candidates, k) = Kth(candidates, k);

IEnumerable<SyntaxNode> candidates := Find(constraint, subtrees)
                                    = Filter(\x: SyntaxNode => constraint, subtrees);

IEnumerable<SyntaxNode> subtrees := Sub(ancestor);

SyntaxNode ancestor := Just(source) | AbsAncestor(source, k) | RelAncestor(source, label, k);

bool constraint := Any(x)
                 | AnyError(x)
                 | AnyToken(x) | TokenMatch(x, label)
                 | AnyNode(x) | NodeMatch(x, label);

int k;
int i;
Label label;
string code;