using System.Collections.Generic;

using Prem.Util;
using Prem.Transformer.TreeLang;

using semantics Prem.Transformer.TreeLang.Semantics;
using learners Prem.Transformer.TreeLang.WitnessFunctions;

language TreeLang;

@complete feature double Score = Prem.Transformer.TreeLang.RankingScore;

@input TInput source;

@start SyntaxNode program := Ins(target, k, newTree) | Del(target) | Upd(target, newTree);

SyntaxNode newTree := New(tree);

PartialNode tree := Copy(target) | Leaf(label, token) | Tree(label, children);

IEnumerable<PartialNode> children := Child(tree) | Children(tree, children);

SyntaxNode target := Just(source) | ancestor | Find(ancestor, matcher);

SyntaxNode ancestor := AbsAnc(source, k) | RelAnc(source, label, k);

Func<SyntaxNode, bool> matcher := Match(predicate, siblingMatcher);

Func<SyntaxNode, bool> siblingMatcher := MatchS(locator, predicate);

Func<SyntaxNode, bool> predicate := True() | atom | And(atom, predicate);

Func<SyntaxNode, bool> atom := MatchL(label) | MatchT(token);

string token := Const(s) | Var(source, i) | FindE(source, matcher);

int k;
int i;
string s;

Label label;
SiblingLocator locator;