using System.Collections.Generic;
using Microsoft.ProgramSynthesis.Utils;

using Prem.Util;
using Prem.Transformer.TreeLang;

using semantics Prem.Transformer.TreeLang.Semantics;
using learners Prem.Transformer.TreeLang.PremStrategy;

language TreeLang;

@complete feature double Score = Prem.Transformer.TreeLang.RankingScore;

@input TInput old;

@start SyntaxNode program := Transform(target, newTree);

SyntaxNode target := Err(old) | ref;

SyntaxNode ref := scope | Select(scope, index, selector);

Node scope := LiftScope(old, label, k) | VarScope(old, label, label, key);

Optional<Func<SyntaxNode, bool>> selector := Self()
                                          | Label(label) 
                                          | LabelSub(label, label)
                                          | LabelWith(label, featurePair);

Record<Label, string>? featurePair := Feature(label, token) = Pair(label, token);

string token := Const(s) | Var(old, key) | FeatureString(old, label, k, index, label);

SyntaxNode newTree := New(tree);

PartialNode tree := Copy(ref) | Leaf(label, token) | Node(label, children) | ListNode(label, siblings);

IEnumerable<PartialNode> children := Child(tree) | Children(tree, children);

IEnumerable<PartialNode> siblings := Append(tree, siblings) | Prepend(tree, siblings)
                                   | Front(ref) | Tail(ref) | Siblings(ref);

int index;
int k;
string s;
Label label;
EnvKey key;